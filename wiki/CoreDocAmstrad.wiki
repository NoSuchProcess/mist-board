#summary documentation for the Amstrad core
#labels Phase-Requirements,Phase-Design

= Introduction =

Welcome to Amstrad core for MiST-board.

This is a deployment of FPGAmstrad into MiST-board.

Known running games : Asphalt, Bruce Lee, Buggy Boy, Dan Dare 1 & 2, Donkey Kong, Fruity Frank, Hold-up, Impossible Mission, Macadam Bumper, Prince of Percia, RAID (?), Rick Dangerous 1 & 2, Sapiens, Spin Dizzy, Super Ski, Trail Blazer, Wizard's Lair, 1942 1943, Classic Invaders,  Ghost'n'Goblins, Ghould'n'Ghosts, Tempest, Xevious.

Known running demos from CPCRulez demoscene : -Circles, Crazy Demo, Genesis Demo, GPA Demo 1, IFE Demo, TMS Demo 2 (compacted one)
= Installation =

You need :
  * MiST-board platform, with firmware updated [https://code.google.com/p/mist-board/source/browse/trunk/bin/firmware/ >= firmware_150315_r841.upg]
  * [http://code.google.com/p/mist-board/source/browse/#svn/trunk/bin/cores/amstrad amstrad core rbf file]
  * [http://code.google.com/p/mist-board/source/browse/#svn/trunk/bin/cores/amstrad/OS6128_BASIC1-1_AMSDOS_MAXAM amstrad ROMs and a dsk]



Using the OSD menu (F12), do select a dsk.
You can enter *cat* instruction to list dsk content. Executables are files in *.bas* or *.bin*.
You can then enter *run"file.bas* to run the choosen executable.

= Controls =

 * _F1_ _F2_ _F3_ at the top are mapped correctly.
 * _left_ _shift_ is the true shift key. _Right_ _shift_ one is used just to map flipper key in Macadam Bumper (I like playing flipper using shift keys).
 * _shift+arrow_ does move the second cursor, and _insert_ does copy letters that are under the second cursor. That's it : _insert_ key is mapped to original _copy_ key.
 * _Page up_ does reset Amstrad

= Developing, translating, deploying =

This core is a deploy of FPGAmstrad from NEXYS4 Diligent development board into MiST final board

FPGAmstrad is a translate of JavaCPC from Java into VHDL (electronic language), it is about *reverse engineering*, resulting an original Amstrad clone.

JavaCPC is an Amstrad CPC 6128 emulator developed by Markus Hohmann.


In this wiki page, you'll find all about my deployment strategy.

In FPGAmstrad's page http://www.cpcwiki.eu/index.php/FPGAmstrad, you'll find all about game bug localisation, and a TODO-list.

From Markus Hohmann homepage http://cpc.devilmarkus.de, you can try others games, playing them directly from your web navigator :)

= From Xilinx to Altera schematics =
For me, global schematics are really important, for developing and for deploying.
A schematic developed in order to be comparable to original documentation schematic is nice. FPGAmstrad is composed of 3 schematics :
  * amstrad_motherboard : comparable to original Amstrad schematic.
  * amstrad_video : does manage a true VGA output, using a internal VRAM.
  * bootloader_sd : sdcard bootloader, in order to load ROM and dsk at boot, from sdcard.

As Xilinx schematics are not compatible with Altera, I do generate "vhf" files, and rename them :
  * FPGAmstrad_amstrad_motherboard.vhd
  * FPGAmstrad_amstrad_video.vhd
  * FPGAmstrad_bootloader_sd.vhd

And then I make a global schematic in Altera, that contains the previous components, and several MiST-board controlers :
  * FPGAmstrad_amstrad_motherboard.vhd
  * FPGAmstrad_amstrad_video.vhd
  * FPGAmstrad_bootloader_sd.vhd
  * sdcard.v
  * user_io.v
  * data_io.v
  * sdram.v
  * osd.v

I create then a main clock component, generating all clocks I want even the not clocks (a good practice, while using "time constraints"),
I also add some adapters, about wire/bus range solving :
  * MIST_SDRAM.vhd : each SDRAM has a different RAM bus size
  * MIST_DQM.vhd : just a small wiring helper
  * MIST_RGB.vhd : each VGA output has different count of colors
  * MIST_STATUS.vhd : mapping status wires
  * CONF_STR.vhd : generating OSD parameter

= Xilinx to Altera =
While generating vhf files from Xilinx Schematics, a lot of small components have to be adapted :
  * INV component became 'not' instruction
  * AND2 component became 'and' instruction
  * OR2 component became 'or instruction
  * GND component became '0' value
  * VCC component became '1' value
The internal RAM, sync and async (with one or two clocks) are to adapt, I use mem_altera_gen.vhd for this purpose.

= Special things done during deploy =

sdram.v is personalized in order to solve address *after* the write or read event. It is due to Amstrad that permit writing in RAM hidden inside ROM : if I read I read ROM, if I write I write RAM.
sdram.v is also personalized in order having a clkref lower than 4MHz.

As I could not do enter my 32KB VRAM, I used a 16KB+8KB+4KB VRAM, to display the 640x480 output.

In NEXYS4's version I use also a 32KB mirror VRAM reflecting C000-FFFF and 8000-BFFF, alternating between C000-FFF and 8000-BFFF is called using a double VRAM buffer.
In MiST board only the C000-FFFF area is mirrored, so I add an option in OSD menu about playing with the A14 wire : you can detach -open- this wire or attach it in order having x"00" as output of 8000-BFFF area.
That will help to detect/classify games needing more than 16KB of mirror VRAM.

= Future =
Next actions are same as FPGAmstrad's TODO-list.

= Return =
  * 1943 show an evidence about problem reading/writing on a VRAM at two different speed. A scan-doubler component needs to be used in order to solve that sort of problem.
  * A lot of games were lost in this deploy due to 16KB only mirror VRAM. A scan-doubler component needs to be used in order to solve that sort of problem.
  * A lot of games and demos were unlocked since I personalized the SDRAM controler, all about that will be reported back into FPGAmstrad project.
  * PWM was greatly ameliorated during this deploy, all about that will be reported back into FPGAmstrad project.
  * A small effort was done about interrupt cycles during this deploy, unlocking some demos, all about that will be reported back into FPGAmstrad project.
  * This project do compile in Xilinx and in Altera, but some files have to be edited each time I switch. That have to be ameliored.