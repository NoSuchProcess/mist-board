#summary One-sentence summary of this page.
#sidebar CoreDocTOC

== Introduction ==

In this wiki page, you'll find all the FPGAmstrad development strategy.

In FPGAmstrad's page http://www.cpcwiki.eu/index.php/FPGAmstrad, you'll find all about game bug localisation, and a TODO-list.

From Markus Hohmann homepage http://cpc.devilmarkus.de, you can try others games, playing them directly from your internet browser :)

= From Xilinx to Altera schematics =
For me, global schematics are really important, for developing and for deploying.
A schematic developed in order to be comparable to original documentation schematic is nice. FPGAmstrad is composed of 3 schematics :
  * amstrad_motherboard : comparable to original Amstrad schematic.
  * amstrad_video : does manage a true VGA output, using a internal VRAM.
  * bootloader_sd : sdcard bootloader, in order to load ROM and dsk at boot, from sdcard.

As Xilinx schematics are not compatible with Altera, I do generate "vhf" files, and rename them :
  * FPGAmstrad_amstrad_motherboard.vhd
  * FPGAmstrad_amstrad_video.vhd
  * FPGAmstrad_bootloader_sd.vhd

And then I make a global schematic in Altera, that contains the previous components, and several MiST-board controlers :
  * FPGAmstrad_amstrad_motherboard.vhd
  * FPGAmstrad_amstrad_video.vhd
  * FPGAmstrad_bootloader_sd.vhd
  * sdcard.v
  * user_io.v
  * data_io.v
  * sdram.v
  * osd.v

I create then a main clock component, generating all clocks I want even the not clocks (a good practice, while using "time constraints"),
I also add some adapters, about wire/bus range solving :
  * MIST_SDRAM.vhd : each SDRAM has a different RAM bus size
  * MIST_DQM.vhd : just a small wiring helper
  * MIST_RGB.vhd : each VGA output has different count of colors
  * MIST_STATUS.vhd : mapping status wires
  * CONF_STR.vhd : generating OSD parameter

= Xilinx to Altera =
While generating vhf files from Xilinx Schematics, a lot of small components have to be adapted :
  * INV component became 'not' instruction
  * AND2 component became 'and' instruction
  * OR2 component became 'or instruction
  * GND component became '0' value
  * VCC component became '1' value
The internal RAM, sync and async (with one or two clocks) are to adapt, I use mem_altera_gen.vhd for this purpose.

= Special things done during deploy =

sdram.v is personalized in order to solve address *after* the write or read event. It is due to Amstrad that permit writing in RAM hidden inside ROM : if I read I read ROM, if I write I write RAM.
sdram.v is also personalized in order having a clkref lower than 4MHz.

As I could not do enter my 32KB VRAM, I used a 16KB+8KB+4KB VRAM, to display the 640x480 output.

In NEXYS4's version I use also a 32KB mirror VRAM reflecting C000-FFFF and 8000-BFFF, alternating between C000-FFF and 8000-BFFF is called using a double VRAM buffer.
In MiST board only the C000-FFFF area is mirrored, so I add an option in OSD menu about playing with the A14 wire : you can detach -open- this wire or attach it in order having x"00" as output of 8000-BFFF area.
That will help to detect/classify games needing more than 16KB of mirror VRAM.

This 16KB is a mirror VRAM written at 4MHz and load at 4MHz, so a synchronous internal RAM running at 8MHz (synchronized with 4MHz in another process) shall do the stuff. I'm currently learning about "inferred RAM" : big variable (reg) compiled (fitted) as internal RAM instead of simple variable (reg)

= RAM optimization =

Here, I'm working about winning more internal FPGA RAM, it's WIP.

RAM inferred : [http://quartushelp.altera.com/13.0/mergedProjects/hdl/vlog/vlog_file_dir_ram.htm in Altera reg is inferred into RAM-block], so a reg written like this :
{{{
reg [7:0] dir_entry_reg [31:0]
}}}
became RAM-block.

In data_io.v : dir_entry_reg does use /* synthesis noprune */ in order to be not unwired. If I remove output dir_entry_d, RAM-block is inferred. If I let output dir_entry_d, LOGIC-block is inferred.

So I removed output dir_entry_d and set :
{{{
(* ramstyle = "logic" *) reg [7:0] dir_entry_reg [31:0] /* synthesis noprune */;
}}}
So I continue winning my 1KB internal RAM-block (here 256 Bytes was needed and turn into inferred LOGIC-block)

In sdcard.v
{{{
reg [7:0] buffer [511:0];
}}}
is a big reg and really important one (speaking to ARM SPI !), so I let it inferring into RAM-block.
But about cid and csd I does :
{{{
(* ramstyle = "logic" *) reg [7:0] cid [15:0];
(* ramstyle = "logic" *) reg [7:0] csd [15:0];
}}}
Winning 2KB of internal RAM for this small 128Bytes reg :)

In VRAM_Palette, I had 16KB. But in fact a raster line is a 2+16+1 RAM palette line, so each line I store 19KB, so in fact 19*600/2=5700 bytes (800x600 VRAM in fact thruly 800x300). So only a 8KB RAM palette only was needed in FPGAmstrad project finally.

Result of this WIP : I won 10KB of internal RAM (I need 6KB more to succeed in my full FPGAmstrad deployment)

WIP : I think about nibbling 2KB more at end of RAM palette.
And 4KB in VRAM :
800x600=100*300=30KB full
800x480=100*240=24000 24000-16384=7616<8KB=8192
so VRAM with a start vertical offset can be composed of 16KB+8KB only. So I may win my last 4KB here.
Over way if I just remove the first 4KB, my display does draw at top (600-480)/4=30 lines, 30*100=3000 so bytes are hidden at top (VRAM is 800x600 centered, and displayed finally 640x480)... but 3000<4096 so it doesn't pass. I need this start vertical offset patch, I cannot just remove a block of RAM like this.

= Future =
Next actions are same as FPGAmstrad's TODO-list.

= Return =
  * 1943 show an evidence about problem reading/writing on a VRAM at two different speed. A scan-doubler component needs to be used in order to solve that sort of problem.
  * A lot of games were lost in this deploy due to 16KB only mirror VRAM. A scan-doubler component needs to be used in order to solve that sort of problem.
  * A lot of games and demos were unlocked since I personalized the SDRAM controler, all about that will be reported back into FPGAmstrad project.
  * PWM was greatly ameliorated during this deploy, all about that will be reported back into FPGAmstrad project.
  * A small effort was done about interrupt cycles during this deploy, unlocking some demos, all about that will be reported back into FPGAmstrad project.
  * This project do compile in Xilinx and in Altera, but some files have to be edited each time I switch. That has to be improved.